"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const stripBom = require("strip-bom");
const transform_1 = require("../../../brocc/transform");
const entry_point_1 = require("../../../ng-package-format/entry-point");
const log = require("../../../util/log");
const entry_point_node_1 = require("../../entry-point.node");
// CSS Tools
const autoprefixer = require("autoprefixer");
const browserslist = require("browserslist");
const postcss = require("postcss");
const sass = require("node-sass");
const nodeSassTildeImporter = require("node-sass-tilde-importer");
const less = require("less");
const stylus = require("stylus");
const postcssUrl = require("postcss-url");
const postcssComments = require("postcss-discard-comments");
exports.stylesheetTransform = transform_1.transformFromPromise((graph) => __awaiter(this, void 0, void 0, function* () {
    log.info(`Rendering Stylesheets`);
    // TODO: fetch current entry point from graph
    const entryPoint = graph.find(entry_point_node_1.byEntryPoint().and(entry_point_node_1.isInProgress));
    // TODO: fetch nodes from the graph
    const stylesheetNodes = graph.from(entryPoint).filter(node => node.type === 'text/css' && node.state !== 'done');
    // TODO: detemrine base path from NgPackage
    const ngPkg = graph.find(node => node.type === 'application/ng-package');
    const basePath = ngPkg.data.basePath;
    yield Promise.all(stylesheetNodes.map((stylesheetNode) => __awaiter(this, void 0, void 0, function* () {
        const filePath = stylesheetNode.url.substring('file://'.length);
        // preprocessor (render)
        const renderedCss = yield renderPreProcessor(filePath, basePath, entryPoint.data.entryPoint);
        // postcss (autoprefixing, et al)
        const result = yield renderPostCss(filePath, renderedCss, entryPoint.data.entryPoint.cssUrl);
        // TODO: update nodes in the graph
        stylesheetNode.data = Object.assign({}, stylesheetNode.data, { content: result });
    })));
    // TODO: await forEach() ?!?
    return graph;
}));
function renderPostCss(filePath, cssStyles, cssUrl) {
    return __awaiter(this, void 0, void 0, function* () {
        log.debug(`determine browserslist for ${filePath}`);
        const browsers = browserslist(undefined, { filePath });
        const postCssPlugins = [autoprefixer({ browsers }), postcssComments({ removeAll: true })];
        if (cssUrl !== entry_point_1.CssUrl.none) {
            log.debug(`postcssUrl: ${cssUrl}`);
            postCssPlugins.push(postcssUrl({ url: cssUrl }));
        }
        const result = yield postcss(postCssPlugins).process(cssStyles, {
            from: filePath,
            to: filePath.replace(path.extname(filePath), '.css')
        });
        // Escape existing backslashes for the final output into a string literal, which would otherwise escape the character after it
        result.css = result.css.replace(/\\/g, '\\\\');
        // Log warnings from postcss
        result.warnings().forEach(msg => {
            log.warn(msg.toString());
        });
        return result.css;
    });
}
function renderPreProcessor(filePath, basePath, entryPoint) {
    return __awaiter(this, void 0, void 0, function* () {
        log.debug(`Render styles for ${filePath}`);
        switch (path.extname(filePath)) {
            case '.scss':
            case '.sass':
                log.debug(`rendering sass from ${filePath}`);
                return renderSass({
                    file: filePath,
                    importer: nodeSassTildeImporter,
                    includePaths: entryPoint.sassIncludePaths
                });
            case '.less':
                log.debug(`rendering less from ${filePath}`);
                return renderLess({ filename: filePath });
            case '.styl':
            case '.stylus':
                log.debug(`rendering styl from ${filePath}`);
                return renderStylus({ filename: filePath, root: basePath });
            case '.css':
            default:
                log.debug(`reading css from ${filePath}`);
                return fs.readFile(filePath).then(buffer => stripBom(buffer.toString()));
        }
    });
}
const renderSass = (sassOpts) => {
    return new Promise((resolve, reject) => {
        sass.render(sassOpts, (err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result.css.toString());
            }
        });
    });
};
const renderLess = (lessOpts) => {
    return fs
        .readFile(lessOpts.filename)
        .then(buffer => stripBom(buffer.toString()))
        .then((lessData) => new Promise((resolve, reject) => {
        less.render(lessData || '', lessOpts, (err, result) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(result.css.toString());
            }
        });
    }));
};
/**
 * filename - absolute path to file
 * root - root folder of project (where ng-package.json is located)
 */
const renderStylus = ({ filename, root }) => {
    return fs
        .readFile(filename)
        .then(buffer => stripBom(buffer.toString()))
        .then((stylusData) => new Promise((resolve, reject) => {
        stylus(stylusData)
            .include(root)
            .include('.')
            .include('node_modules')
            .set('filename', filename)
            .set('resolve url', true)
            .define('url', stylus.resolver())
            .render((err, css) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(css);
            }
        });
    }));
};
//# sourceMappingURL=stylesheet.transform.js.map