{"version":3,"file":"remap.js","sourceRoot":"","sources":["../../../src/lib/sourcemaps/remap.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,mCAAmC;AACnC,mCAAmC;AAEnC;;;;;GAKG;AACH,wBAAqC,UAAkB;;QACrD,GAAG,CAAC,KAAK,CAAC,0BAA0B,UAAU,EAAE,CAAC,CAAC;QAClD,MAAM,IAAI,GAAQ;YAChB,MAAM,EAAE,KAAK;YACb,cAAc,EAAE,IAAI;SACrB,CAAC;QAEF,gGAAgG;QAChG,MAAM,KAAK,GAAG,MAAM,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAC7C,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACX,MAAM,IAAI,KAAK,CAAC,qCAAqC,GAAG,UAAU,CAAC,CAAC;QACtE,CAAC;QAED,MAAM,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;CAAA;AAdD,wCAcC","sourcesContent":["import * as sorcery from 'sorcery';\nimport * as log from '../util/log';\n\n/**\n * Re-maps the source `.map` file for the given `sourceFile`. This keeps source maps intact over\n * a series of transpilations!\n *\n * @param sourceFile Source file\n */\nexport async function remapSourceMap(sourceFile: string): Promise<void> {\n  log.debug(`re-mapping sources for ${sourceFile}`);\n  const opts: any = {\n    inline: false,\n    includeContent: true\n  };\n\n  // Once sorcery loads the chain of sourcemaps, the new sourcemap will be written asynchronously.\n  const chain = await sorcery.load(sourceFile);\n  if (!chain) {\n    throw new Error('Failed to load sourceMap chain for ' + sourceFile);\n  }\n\n  await chain.write(opts);\n}\n"]}